\section{Utils}

\subsection{Binary Search}
\lstinputlisting[language=C++]{secciones/utils/bs.cpp}

\subsection{Sort}
Ordenar un vector de pair por su segunda componente
\begin{lstlisting}[language=C++]
vector<pair<int, int>> v;

bool sortbysec(const pair<int,int> &a, const pair<int,int> &b){
	return (a.second < b.second);
}

sort(v.begin(), v.end(), sortbysec);
\end{lstlisting}
\subsection{Cout para doubles}
\begin{lstlisting}[language=C++]
cout << fixed << setprecision(20) << ans << endl;
\end{lstlisting}
\subsection{Prev permutation}
\lstinputlisting[language=C++]{secciones/utils/prevpermutation.cpp}
\subsection{MO}
\lstinputlisting[language=C++]{secciones/utils/mo.cpp}

\subsection{Criba}
Nros primos hasta maxp
\lstinputlisting[language=C++]{secciones/utils/criba.cpp}

\subsection{Subconjuntos}
Subconjuntos distintos de un conjunto
\lstinputlisting[language=C++]{secciones/utils/Subconjuntos.cpp}

\subsection{Propiedades del Bitwise XOR ($\oplus$)}
\begin{enumerate}
    \item \textbf{Identidad:} 
    \[
    a \oplus 0 = a
    \]

    \item \textbf{Autoinversión:} 
    \[
    a \oplus a = 0
    \]

    \item \textbf{Conmutativa:} 
    \[
    a \oplus b = b \oplus a
    \]

    \item \textbf{Asociativa:} 
    \[
    (a \oplus b) \oplus c = a \oplus (b \oplus c)
    \]

    \item \textbf{Autoeliminación:} 
    \[
    a \oplus a \oplus b = 0 \oplus b = b
    \]

    \item \textbf{Uso práctico: Encontrar elemento único} \\
    Si todos los elementos de un conjunto aparecen dos veces excepto uno:
    \[
    x_1 \oplus x_2 \oplus \dots \oplus x_n = \text{elemento único}
    \]
\end{enumerate}

\newpage


